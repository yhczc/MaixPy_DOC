{"./":{"url":"./","title":"Introduction","keywords":"","body":"MaixPy Documentation What is MaixPy MaixPy is a Micropython port on 64Bit Dual-Core RISC-V CPU K210, MicroPython is a lean and efficient implementation of the Python 3 programming language that includes a small subset of the Python standard library and is optimised to run on microcontrollers and in constrained environments. K210 created for AIOT(AI+IOT) use, It's powerful performance and low cost are very competitive. Micropython make program on hardware(K210) easier, so we build this and open source on github) For example if we want to find I2C device, we just need code: from machine import I2C i2c = I2C(I2C.I2C0, freq=100000, scl=28, sda=29) devices = i2c.scan() print(devices) If we want to make a breathing light by PWM, we just need code: from machine import Timer,PWM import time tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PWM) ch = PWM(tim, freq=500000, duty=50, pin=board_info.LED_G) duty=0 dir = True while True: if dir: duty += 10 else: duty -= 10 if duty>100: duty = 100 dir = False elif duty About this documentation Everything related to Maixpy, mainly about How to get a hardware( board ) How to get start with MaixPy even we are not so be expert in program for hardware. Learn Micropython basic knowledge Libriaries(API) reference Let's get started To get started, we need one dev board, there's three kind of board as follow: Dan dock with Sipeed M1(Dan) module Sipeed Maix BiT Sipeed Go To get these board, visit Sipeed official website More hardware infomation here Then we can write software, refer to get started Source code MaixPy source code on github Maintained by ©Sipeed Co.,Ltd. More contributor here Source code of MaixPy documentation Doumentation will be edit if code api changed, source of doc on github branch page build status master dev Feedback Doc feedback Code feedback "},"hardware/k210.html":{"url":"hardware/k210.html","title":"K210","keywords":"","body":"K210 "},"hardware/module.html":{"url":"hardware/module.html","title":"Module","keywords":"","body":"Modules Sipeed M1 (Lichee Dan) "},"hardware/m1.html":{"url":"hardware/m1.html","title":"Sipeed M1","keywords":"","body":"Sipeed M1 (Lichee Dan) "},"hardware/board.html":{"url":"hardware/board.html","title":"Board","keywords":"","body":"Board there's three kind of board as follow: Dan dock with Sipeed M1(Dan) module Sipeed Maix BiT Sipeed Go "},"hardware/dan_dock.html":{"url":"hardware/dan_dock.html","title":"Dan Dock","keywords":"","body":"Sipeed M1 (Lichee Dan) Dan dock with Sipeed M1(Dan) module "},"hardware/bit.html":{"url":"hardware/bit.html","title":"BiT","keywords":"","body":"Sipeed Maix BiT "},"hardware/go.html":{"url":"hardware/go.html","title":"Go","keywords":"","body":"Sipeed Maix Go "},"hardware/peripheral_modules.html":{"url":"hardware/peripheral_modules.html","title":"Peripheral Modules","keywords":"","body":"Peripheral Modules Microphone array Binocular camera "},"get_started/prepare.html":{"url":"get_started/prepare.html","title":"Prepare","keywords":"","body":""},"get_started/get_hardware.html":{"url":"get_started/get_hardware.html","title":"Get Hardware","keywords":"","body":""},"get_started/upgrade_firmware.html":{"url":"get_started/upgrade_firmware.html","title":"Upgrade Firmware","keywords":"","body":""},"get_started/power_on.html":{"url":"get_started/power_on.html","title":"Power On","keywords":"","body":""},"get_started/led_blink.html":{"url":"get_started/led_blink.html","title":"LED Blink","keywords":"","body":""},"get_started/how_to_read.html":{"url":"get_started/how_to_read.html","title":"How To Read Docs","keywords":"","body":""},"mpy_basic_syntax/":{"url":"mpy_basic_syntax/","title":"Basic Syntax","keywords":"","body":"Micropython basic syntax "},"libs/":{"url":"libs/","title":"Libraries","keywords":"","body":"Libraries standard machine "},"libs/standard/":{"url":"libs/standard/","title":"standard","keywords":"","body":"standard libs cmath gc math sys ubinascii ucollections uctypes uerrno uheapq ujson uos ure uselect ustruct utime uzlib "},"libs/standard/cmath.html":{"url":"libs/standard/cmath.html","title":"cmath","keywords":"","body":"cmath – mathematical functions for complex numbers This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: cmath. The cmath module provides some basic mathematical functions for working with complex numbers. Availability: not available on WiPy and ESP8266. Floating point support required for this module. Functions cos cmath.cos(z) Return the cosine of z. exp cmath.exp(z) Return the exponential of z. log cmath.log(z) Return the natural logarithm of z. The branch cut is along the negative real axis. log10 cmath.log10(z) Return the base-10 logarithm of z. The branch cut is along the negative real axis. phase cmath.phase(z) Returns the phase of the number z, in the range (-pi, +pi]. polar cmath.polar(z) Returns, as a tuple, the polar form of z. rect cmath.rect(r, phi) Returns the complex number with modulus r and phase phi. sin cmath.sin(z) Return the sine of z. sqrt cmath.sqrt(z) Return the square-root of z. Constants cmath.e base of the natural logarithm cmath.pi the ratio of a circle’s circumference to its diameter "},"libs/standard/gc.html":{"url":"libs/standard/gc.html","title":"gc","keywords":"","body":"gc – control the garbage collector This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: gc. Functions gc.enable() Enable automatic garbage collection. gc.disable() Disable automatic garbage collection. Heap memory can still be allocated, and garbage collection can still be initiated manually using gc.collect(). gc.collect() Run a garbage collection. gc.mem_alloc() Return the number of bytes of heap RAM that are allocated. Difference to CPython This function is MicroPython extension. gc.mem_free() Return the number of bytes of available heap RAM, or -1 if this amount is not known. Difference to CPython This function is MicroPython extension. gc.threshold([amount]) Set or query the additional GC allocation threshold. Normally, a collection is triggered only when a new allocation cannot be satisfied, i.e. on an out-of-memory (OOM) condition. If this function is called, in addition to OOM, a collection will be triggered each time after amount bytes have been allocated (in total, since the previous time such an amount of bytes have been allocated). amount is usually specified as less than the full heap size, with the intention to trigger a collection earlier than when the heap becomes exhausted, and in the hope that an early collection will prevent excessive memory fragmentation. This is a heuristic measure, the effect of which will vary from application to application, as well as the optimal value of the amount parameter. Calling the function without argument will return the current value of the threshold. A value of -1 means a disabled allocation threshold. Difference to CPython This function is a MicroPython extension. CPython has a similar function - set_threshold(), but due to different GC implementations, its signature and semantics are different. "},"libs/standard/math.html":{"url":"libs/standard/math.html","title":"math","keywords":"","body":"math – mathematical functions This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: math. The math module provides some basic mathematical functions for working with floating-point numbers. Note: On the pyboard, floating-point numbers have 32-bit precision. Availability: not available on WiPy. Floating point support required for this module. Functions math.acos(x) Return the inverse cosine of x. math.acosh(x) Return the inverse hyperbolic cosine of x. math.asin(x) Return the inverse sine of x. math.asinh(x) Return the inverse hyperbolic sine of x. math.atan(x) Return the inverse tangent of x. math.atan2(y, x) Return the principal value of the inverse tangent of y/x. math.atanh(x) Return the inverse hyperbolic tangent of x. math.ceil(x) Return an integer, being x rounded towards positive infinity. math.copysign(x, y) Return x with the sign of y. math.cos(x) Return the cosine of x. math.cosh(x) Return the hyperbolic cosine of x. math.degrees(x) Return radians x converted to degrees. math.erf(x) Return the error function of x. math.erfc(x) Return the complementary error function of x. math.exp(x) Return the exponential of x. math.expm1(x) Return exp(x) - 1. math.fabs(x) Return the absolute value of x. math.floor(x) Return an integer, being x rounded towards negative infinity. math.fmod(x, y) Return the remainder of x/y. math.frexp(x) Decomposes a floating-point number into its mantissa and exponent. The returned value is the tuple (m, e) such that x == m * 2**e exactly. If x == 0 then the function returns (0.0, 0), otherwise the relation 0.5 holds. math.gamma(x) Return the gamma function of x. math.isfinite(x) Return True if x is finite. math.isinf(x) Return True if x is infinite. math.isnan(x) Return True if x is not-a-number math.ldexp(x, exp) Return x * (2**exp). math.lgamma(x) Return the natural logarithm of the gamma function of x. math.log(x) Return the natural logarithm of x. math.log10(x) Return the base-10 logarithm of x. math.log2(x) Return the base-2 logarithm of x. math.modf(x) Return a tuple of two floats, being the fractional and integral parts of x. Both return values have the same sign as x. math.pow(x, y) Returns x to the power of y. math.radians(x) Return degrees x converted to radians. math.sin(x) Return the sine of x. math.sinh(x) Return the hyperbolic sine of x. math.sqrt(x) Return the square root of x. math.tan(x) Return the tangent of x. math.tanh(x) Return the hyperbolic tangent of x. math.trunc(x) Return an integer, being x rounded towards 0. Constants math.e base of the natural logarithm math.pi the ratio of a circle’s circumference to its diameter "},"libs/standard/sys.html":{"url":"libs/standard/sys.html","title":"sys","keywords":"","body":""},"libs/standard/ubinascii.html":{"url":"libs/standard/ubinascii.html","title":"ubinascii","keywords":"","body":"ubinascii – binary/ASCII conversions This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: binascii. This module implements conversions between binary data and various encodings of it in ASCII form (in both directions). Functions ubinascii.hexlify(data[, sep]) Convert binary data to hexadecimal representation. Returns bytes string. Difference to CPython If additional argument, sep is supplied, it is used as a separator between hexadecimal values. ubinascii.unhexlify(data) Convert hexadecimal data to binary representation. Returns bytes string. (i.e. inverse of hexlify) ubinascii.a2b_base64(data) Decode base64-encoded data, ignoring invalid characters in the input. Conforms to RFC 2045 s.6.8. Returns a bytes object. ubinascii.b2a_base64(data) Encode binary data in base64 format, as in RFC 3548. Returns the encoded data followed by a newline character, as a bytes object. "},"libs/standard/ucollections.html":{"url":"libs/standard/ucollections.html","title":"ucollections","keywords":"","body":"ucollections – collection and container types This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: collections. This module implements advanced collection and container types to hold/accumulate various objects. Classes ucollections.deque(iterable, maxlen[, flags]) Deques (double-ended queues) are a list-like container that support O(1) appends and pops from either side of the deque. New deques are created using the following arguments: iterable must be the empty tuple, and the new deque is created empty. maxlen must be specified and the deque will be bounded to this maximum length. Once the deque is full, any new items added will discard items from the opposite end. The optional flags can be 1 to check for overflow when adding items. As well as supporting bool and len, deque objects have the following methods: deque.append(x) Add x to the right side of the deque. Raises IndexError if overflow checking is enabled and there is no more room left. deque.popleft() Remove and return an item from the left side of the deque. Raises IndexError if no items are present. ucollections.namedtuple(name, fields) This is factory function to create a new namedtuple type with a specific name and set of fields. A namedtuple is a subclass of tuple which allows to access its fields not just by numeric index, but also with an attribute access syntax using symbolic field names. Fields is a sequence of strings specifying field names. For compatibility with CPython it can also be a a string with space-separated field named (but this is less efficient). Example of use: from ucollections import namedtuple MyTuple = namedtuple(\"MyTuple\", (\"id\", \"name\")) t1 = MyTuple(1, \"foo\") t2 = MyTuple(2, \"bar\") print(t1.name) assert t2.name == t2[1] ucollections.OrderedDict(...) dict type subclass which remembers and preserves the order of keys added. When ordered dict is iterated over, keys/items are returned in the order they were added: from ucollections import OrderedDict # To make benefit of ordered keys, OrderedDict should be initialized # from sequence of (key, value) pairs. d = OrderedDict([(\"z\", 1), (\"a\", 2)]) # More items can be added as usual d[\"w\"] = 5 d[\"b\"] = 3 for k, v in d.items(): print(k, v) Output: z 1 a 2 w 5 b 3 "},"libs/standard/uerrno.html":{"url":"libs/standard/uerrno.html","title":"uerrno","keywords":"","body":"uerrno — system error codes This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: errno. This module provides access to symbolic error codes for OSError exception. A particular inventory of codes depends on MicroPython port， Will explain the specific function that will cause an error. Constants EEXIST, EAGAIN, etc. Error codes, based on ANSI C/POSIX standard. All error codes start with “E”. As mentioned above, inventory of the codes depends on MicroPython port. Errors are usually accessible as exc.args[0] where exc is an instance of OSError. Usage example: try: uos.mkdir(\"my_dir\") except OSError as exc: if exc.args[0] == uerrno.EEXIST: print(\"Directory already exists\") uerrno.errorcode Dictionary mapping numeric error codes to strings with symbolic error code (see above): >>> print(uerrno.errorcode[uerrno.EEXIST]) EEXIST "},"libs/standard/uheapq.html":{"url":"libs/standard/uheapq.html","title":"uheapq","keywords":"","body":"uheapq – heap queue algorithm This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: heapq. This module implements the heap queue algorithm. A heap queue is simply a list that has its elements stored in a certain way. Functions heappush uheapq.heappush(heap, item) Push the item onto the heap. heappop uheapq.heappop(heap) Pop the first item from the heap, and return it. Raises IndexError if heap is empty. heapify uheapq.heapify(x) Convert the list x into a heap. This is an in-place operation. "},"libs/standard/uos.html":{"url":"libs/standard/uos.html","title":"uos","keywords":"","body":"os "},"libs/standard/ure.html":{"url":"libs/standard/ure.html","title":"ure","keywords":"","body":"see Micropython doc page "},"libs/standard/uselect.html":{"url":"libs/standard/uselect.html","title":"uselect","keywords":"","body":""},"libs/standard/ustruct.html":{"url":"libs/standard/ustruct.html","title":"ustruct","keywords":"","body":"ustruct – pack and unpack primitive data types This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: struct. Supported size/byte order prefixes: @, , >, !. Supported format codes: b, B, h, H, i, I, l, L, q, Q, s, P, f, d (the latter 2 depending on the floating-point support). Functions calcsize ustruct.calcsize(fmt) Return the number of bytes needed to store the given fmt. pack ustruct.pack(fmt, v1, v2, ...) Pack the values v1, v2, … according to the format string fmt. The return value is a bytes object encoding the values. pack_into ustruct.pack_into(fmt, buffer, offset, v1, v2, ...) Pack the values v1, v2, … according to the format string fmt into a buffer starting at offset. offset may be negative to count from the end of buffer. unpack ustruct.unpack(fmt, data) Unpack from the data according to the format string fmt. The return value is a tuple of the unpacked values. unpack_from ustruct.unpack_from(fmt, data, offset=0) Unpack from the data starting at offset according to the format string fmt. offset may be negative to count from the end of buffer. The return value is a tuple of the unpacked values. "},"libs/standard/utime.html":{"url":"libs/standard/utime.html","title":"utime","keywords":"","body":"utime – time related functions This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: time. The utime module provides functions for getting the current time and date, measuring time intervals, and for delays. Time Epoch: Unix port uses standard for POSIX systems epoch of 1970-01-01 00:00:00 UTC. However, embedded ports use epoch of 2000-01-01 00:00:00 UTC. Maintaining actual calendar date/time: This requires a Real Time Clock (RTC). On systems with underlying OS (including some RTOS), an RTC may be implicit. Setting and maintaining actual calendar time is responsibility of OS/RTOS and is done outside of MicroPython, it just uses OS API to query date/time. On baremetal ports however system time depends on machine.RTC() object. The current calendar time may be set using machine.RTC().datetime(tuple) function, and maintained by following means: By a backup battery (which may be an additional, optional component for a particular board). Using networked time protocol (requires setup by a port/user). Set manually by a user on each power-up (many boards then maintain RTC time across hard resets, though some may require setting it again in such case). If actual calendar time is not maintained with a system/MicroPython RTC, functions below which require reference to current absolute time may behave not as expected. Functions utime.localtime([secs]) Convert a time expressed in seconds since the Epoch (see above) into an 8-tuple which contains: (year, month, mday, hour, minute, second, weekday, yearday) If secs is not provided or None, then the current time from the RTC is used. year includes the century (for example 2014). month is 1-12 mday is 1-31 hour is 0-23 minute is 0-59 second is 0-59 weekday is 0-6 for Mon-Sun yearday is 1-366 utime.mktime() This is inverse function of localtime. It’s argument is a full 8-tuple which expresses a time as per localtime. It returns an integer which is the number of seconds since Jan 1, 2000. utime.sleep(seconds) Sleep for the given number of seconds. Some boards may accept seconds as a floating-point number to sleep for a fractional number of seconds. Note that other boards may not accept a floating-point argument, for compatibility with them use sleep_ms() and sleep_us() functions. utime.sleep_ms(ms) Delay for given number of milliseconds, should be positive or 0. utime.sleep_us(us) Delay for given number of microseconds, should be positive or 0. utime.ticks_ms() Returns an increasing millisecond counter with an arbitrary reference point, that wraps around after some value. The wrap-around value is not explicitly exposed, but we will refer to it as TICKS_MAX to simplify discussion. Period of the values is TICKS_PERIOD = TICKS_MAX + 1. TICKS_PERIOD is guaranteed to be a power of two, but otherwise may differ from port to port. The same period value is used for all of ticks_ms(), ticks_us(), ticks_cpu() functions (for simplicity). Thus, these functions will return a value in range [0 .. TICKS_MAX], inclusive, total TICKS_PERIOD values. Note that only non-negative values are used. For the most part, you should treat values returned by these functions as opaque. The only operations available for them are ticks_diff() and ticks_add() functions described below. Note: Performing standard mathematical operations (+, -) or relational operators (, >=) directly on these value will lead to invalid result. Performing mathematical operations and then passing their results as arguments to ticks_diff() or ticks_add() will also lead to invalid results from the latter functions. utime.ticks_us() Just like ticks_ms() above, but in microseconds. utime.ticks_cpu() Similar to ticks_ms() and ticks_us(), but with the highest possible resolution in the system. This is usually CPU clocks, and that’s why the function is named that way. But it doesn’t have to be a CPU clock, some other timing source available in a system (e.g. high-resolution timer) can be used instead. The exact timing unit (resolution) of this function is not specified on utime module level, but documentation for a specific port may provide more specific information. This function is intended for very fine benchmarking or very tight real-time loops. Avoid using it in portable code. Availability: Not every port implements this function. utime.ticks_add(ticks, delta) Offset ticks value by a given number, which can be either positive or negative. Given a ticks value, this function allows to calculate ticks value delta ticks before or after it, following modular-arithmetic definition of tick values (see ticks_ms() above). ticks parameter must be a direct result of call to ticks_ms(), ticks_us(), or ticks_cpu() functions (or from previous call to ticks_add()). However, delta can be an arbitrary integer number or numeric expression. ticks_add() is useful for calculating deadlines for events/tasks. (Note: you must use ticks_diff() function to work with deadlines.) Examples: # Find out what ticks value there was 100ms ago print(ticks_add(time.ticks_ms(), -100)) # Calculate deadline for operation and test for it deadline = ticks_add(time.ticks_ms(), 200) while ticks_diff(deadline, time.ticks_ms()) > 0: do_a_little_of_something() # Find out TICKS_MAX used by this port print(ticks_add(0, -1)) utime.ticks_diff(ticks1, ticks2) Measure ticks difference between values returned from ticks_ms(), ticks_us(), or ticks_cpu() functions, as a signed value which may wrap around. The argument order is the same as for subtraction operator, ticks_diff(ticks1, ticks2) has the same meaning as ticks1 - ticks2. However, values returned by ticks_ms(), etc. functions may wrap around, so directly using subtraction on them will produce incorrect result. That is why ticks_diff() is needed, it implements modular (or more specifically, ring) arithmetics to produce correct result even for wrap-around values (as long as they not too distant inbetween, see below). The function returns signed value in the range [-TICKS_PERIOD/2 .. TICKS_PERIOD/2-1] (that’s a typical range definition for two’s-complement signed binary integers). If the result is negative, it means that ticks1 occurred earlier in time than ticks2. Otherwise, it means that ticks1 occurred after ticks2. This holds only if ticks1 and ticks2 are apart from each other for no more than TICKS_PERIOD/2-1 ticks. If that does not hold, incorrect result will be returned. Specifically, if two tick values are apart for TICKS_PERIOD/2-1 ticks, that value will be returned by the function. However, if TICKS_PERIOD/2 of real-time ticks has passed between them, the function will return -TICKS_PERIOD/2 instead, i.e. result value will wrap around to the negative range of possible values. Informal rationale of the constraints above: Suppose you are locked in a room with no means to monitor passing of time except a standard 12-notch clock. Then if you look at dial-plate now, and don’t look again for another 13 hours (e.g., if you fall for a long sleep), then once you finally look again, it may seem to you that only 1 hour has passed. To avoid this mistake, just look at the clock regularly. Your application should do the same. “Too long sleep” metaphor also maps directly to application behavior: don’t let your application run any single task for too long. Run tasks in steps, and do time-keeping inbetween. ticks_diff() is designed to accommodate various usage patterns, among them: Polling with timeout. In this case, the order of events is known, and you will deal only with positive results of ticks_diff(): # Wait for GPIO pin to be asserted, but at most 500us start = time.ticks_us() while pin.value() == 0: if time.ticks_diff(time.ticks_us(), start) > 500: raise TimeoutError Scheduling events. In this case, ticks_diff() result may be negative if an event is overdue: # This code snippet is not optimized now = time.ticks_ms() scheduled_time = task.scheduled_time() if ticks_diff(scheduled_time, now) > 0: print(\"Too early, let's nap\") sleep_ms(ticks_diff(scheduled_time, now)) task.run() elif ticks_diff(scheduled_time, now) == 0: print(\"Right at time!\") task.run() elif ticks_diff(scheduled_time, now) Note: Do not pass time() values to ticks_diff(), you should use normal mathematical operations on them. But note that time() may (and will) also overflow. This is known as https://en.wikipedia.org/wiki/Year_2038_problem . utime.time() Returns the number of seconds, as an integer, since the Epoch, assuming that underlying RTC is set and maintained as described above. If an RTC is not set, this function returns number of seconds since a port-specific reference point in time (for embedded boards without a battery-backed RTC, usually since power up or reset). If you want to develop portable MicroPython application, you should not rely on this function to provide higher than second precision. If you need higher precision, use ticks_ms() and ticks_us()functions, if you need calendar time, localtime() without an argument is a better choice. Difference to CPython In CPython, this function returns number of seconds since Unix epoch, 1970-01-01 00:00 UTC, as a floating-point, usually having microsecond precision. With MicroPython, only Unix port uses the same Epoch, and if floating-point precision allows, returns sub-second precision. Embedded hardware usually doesn’t have floating-point precision to represent both long time ranges and subsecond precision, so they use integer value with second precision. Some embedded hardware also lacks battery-powered RTC, so returns number of seconds since last power-up or from other relative, hardware-specific point (e.g. reset). "},"libs/standard/uzlib.html":{"url":"libs/standard/uzlib.html","title":"uzlib","keywords":"","body":"zlib — zlib decompression This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: zlib. This module allows to decompress binary data compressed with DEFLATE algorithm (commonly used in zlib library and gzip archiver). Compression is not yet implemented. Functions decompress uzlib.decompress(data, wbits=0, bufsize=0) Return decompressed data as bytes. wbits is DEFLATE dictionary window size used during compression (8-15, the dictionary size is power of 2 of that value). Additionally, if value is positive, data is assumed to be zlib stream (with zlib header). Otherwise, if it’s negative, it’s assumed to be raw DEFLATE stream. bufsize parameter is for compatibility with CPython and is ignored. DecompIO class uzlib.DecompIO(stream, wbits=0) Create a stream wrapper which allows transparent decompression of compressed data in another stream. This allows to process compressed streams with data larger than available heap size. In addition to values described in decompress(), wbits may take values 24..31 (16 + 8..15), meaning that input stream has gzip header. Difference to CPython This class is MicroPython extension. It’s included on provisional basis and may be changed considerably or removed in later versions. "},"libs/machine/":{"url":"libs/machine/","title":"machine","keywords":"","body":""},"libs/machine/i2c.html":{"url":"libs/machine/i2c.html","title":"I2C","keywords":"","body":"machine.I2C "},"libs/machine/pwm.html":{"url":"libs/machine/pwm.html","title":"PWM","keywords":"","body":"machine.PWM "},"libs/machine/spi.html":{"url":"libs/machine/spi.html","title":"SPI","keywords":"","body":"machine.SPI "},"libs/machine/timer.html":{"url":"libs/machine/timer.html","title":"Timer","keywords":"","body":"machine.Timer Hardware timers deal with timing of periods and events. Timers are perhaps the most flexible and heterogeneous kind of hardware in MCUs and SoCs, differently greatly from a model to a model. MicroPython’s Timer class defines a baseline operation of executing a callback with a given period (or once after some delay), and allow specific boards to define more non-standard behavior (which thus won’t be portable to other boards). Constructors class machine.Timer(id, channel, mode=Timer.MODE_ONE_SHOT, period=1000, unit=Timer.UNIT_MS, callback=None, arg=None, start=True, priority=1, div=0) Construct a new timer object of the given id. Parameters id: Timer ID, [0~2] (Timer.TIMER0~TIMER2) channel: Timer channel, [Timer.CHANNEL0~Timer.CHANNEL3] mode: Timer mode, MODE_ONE_SHOT or MODE_PERIODICor MODE_PWM period: Timer period, after period the callback will be invoke, (0,~). unit: unit of timer, default ms, Timer.UNIT_S or Timer.UNIT_MS or Timer.UNIT_US orTimer.UNIT_NS callback: Timer callback, two parameters, first is Timer, second is user param, see param parameter below. callback execute in interrupt, so don't stay too long in callback arg: Argument dilivered to callback start: If start instantly timer after init, True:start, False:not start, need call start() function. priority: interrupt priority, [1,7]. div: Timer clock divider,[0,255],default to 0. clk_timer = clk_pll0/2^(div+1) clk_timer*period(unit:s) should =1 Methods init Same to constructor Timer.init(id, channel, mode=Timer.MODE_ONE_SHOT, period=1000, unit=Timer.UNIT_MS, callback=None, arg=None, start=True, priority=1, div=0) callback Get or set callback e.g. def on_timer(timer,param): print(\"time up:\",timer) print(\"param:\",param) tim.callback(on_timer) print(on_timer, tim.callback()) period Get or set period e.g. tim.period(2000) print( tim.period() ) start Start timer e.g. tim.start() stop Stop timer restart Restart timer deinit/del Deinitialises the timer. Stops the timer, and disables the timer peripheral. e.g. tim.deinit() or del tim Constants TIMER0: Timer0 id TIMER1: Timer1 id TIMER2: Timer2 id CHANNEL0: Timer channel 0 CHANNEL1: Timer channel 1 CHANNEL2: Timer channel 2 CHANNEL3: Timer channel 3 MODE_ONE_SHOT: Timer only run once MODE_PERIODIC: Timer always run MODE_PWM: Timer used by PWM UNIT_S: unit flag (s) UNIT_MS: unit flag (ms) UNIT_US: unit flag (us) UNIT_NS: unit flag (ns) Demo Demo 1 Print data after 3s just once from machine import Timer def on_timer(timer,param): print(\"time up:\",timer) print(\"param:\",param) tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_ONE_SHOT, period=3000, callback=on_timer, param=on_timer) print(\"period:\",tim.period()) tim.start() Demo 2 Print every 1s, and stop 5s then restart 5s then shutdown import time from machine import Timer def on_timer(timer,param): print(\"time up:\",timer) print(\"param:\",param) tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PERIODIC, period=1, unit=Timer.UNIT_S, callback=on_timer, param=on_timer, start=False, priority=1, div=0) print(\"period:\",tim.period()) tim.start() time.sleep(5) tim.stop() time.sleep(5) tim.restart() time.sleep(5) tim.stop() del tim "},"libs/machine/uart.html":{"url":"libs/machine/uart.html","title":"UART","keywords":"","body":"machine.UART "},"contribute/":{"url":"contribute/","title":"Contribute","keywords":"","body":"Participate in the contribution Since it is an open source project, everyone is welcome to join in to improve MaixPy. Due to the large number of people, we need a common agreement (including format, style, etc.) There are mainly the following aspects that can be involved: document modification MaixPy firmware bug fix, feature optimization, feature addition, etc. "},"contribute/doc_convention.html":{"url":"contribute/doc_convention.html","title":"doc convention","keywords":"","body":"Document specification Documents are built using gitbook and written in simple and efficient Markdown The documentation source is hosted on github Markdown syntax If you never touched the basic syntax of Markdown, please take half an hour to learn, recommend the github tutorial: github Markdown tutorial In this article, we need to pay attention to the following points: The syntax tags of the title class must be separated by spaces. A blank line is required between the headline and the body, such as: ## This is a secondary title * This is list item 1 * This is list item 2 And the following is not correct, it may cause the parser to parse the error format, etc. ##This is a secondary title *This is list item 1 *This is list item 2 All pages have only one top level title Because the need to automatically generate a directory, mainly to ensure that the automatically generated directory is correct. Write each page like this Page title/top level title ======= (There is at least three equals here) (At least one more blank line is required, 2 lines are recommended) ## Secondary title 1 (You cannot use a first-level title here, and you cannot use a ##. You don't need to write a serial number, it will automatically generate a serial number.) ( Skip a line ) text (at least one line) ### Three-level title (similar to the second-level title, it does not need to be written, it will be generated automatically) text ## Secondary title 2 text Link Due to the large number of pages and the need to link resources such as images, relative paths are used when writing links. Such as the directory structure is as follows Assets/ (put public resource files) | ----pic000.png En/ | ----- get_started/ | ---- assets/ (put the resource file common to the md file in the get_started directory) | ------ pic.png | ---- get_hardware.md | ---- how_to_read.md Zh/ If you want to show the images in get_hardware.md, put the image into the assets folder, use the following code to reference the image. ![pic](assets/pic.png) ![pic](../../assets/pic000.png) Chinese and English mixed When writing Chinese documents, the Chinese characters should be separated by spaces as much as possible. Punctuation should use full-width symbols as much as possible. Mainly to make it stand out and make the document more elegant. For example, the following comparison: In Micropython, we often use `deinit` to represent the destructor instead of setting the default value like STM32. In Micropython, we often use deinit to represent the destructor instead of setting the default value like STM32. In Micropython, we often use deinit to represent the destructor, instead of setting the default value like STM32. In Micropython, we often use deinit to represent the destructor, instead of setting the default value like STM32. Directory and file name The generated document directory is edited in the corresponding language folder SUMMARY.md The source document folder should be a function module corresponding to a folder, and the resource file (picture) is placed in the assets folder directory of the current path of the corresponding md document, which is more convenient when adding, deleting, and modifying. Assets/ (put public resource files) En/ | ----- get_started/ | ---- assets/ (put the resource file common to the md file in the get_started directory) | ---- get_hardware.md | ---- how_to_read.md Zh/ The file name is not limited to README.md, other file names are named with lowercase + underscore, such as get_hardware.md Chinese and English (multi-language) page file directory structure and file name are the same Since there are multiple language switching options in the last generated page, clicking the switch will directly access the same path of the corresponding language, so the Chinese and English directory structure and file name must be the same. For example, English is accessing en/get_started/how_to_read.md. After clicking the button for language switching, it will automatically access zh/get_started/how_to_read.md. If this file does not exist, it will report a 404 error! Module Document Content Need to include a module introduction in the file header Need to explain the constructor, function, constant, etc. Explain that you can't be lazy. Simply translate the function name again. You need to explain the function of the function, the range of parameters, and the point of attention "},"contribute/code_convention.html":{"url":"contribute/code_convention.html","title":"code convention","keywords":"","body":"Code Convention "},"others/open_projects.html":{"url":"others/open_projects.html","title":"Open Source Projects","keywords":"","body":"Open source projects related to MaixPy If you have open source project, pull request or tell us by issue or send email(support@sipeed.com)! We are happy to receive your feedback and your contribution! "}}