{"./":{"url":"./","title":"关于MaixPy","keywords":"","body":"MaixPy 文档 什么是 MaixPy MaixPy 是将 Micropython 移植到 K210（ 一款64位双核 RISC-V CPU, ） 的一个项目。 MicroPython 是基于 Python3 的语法做的一款解析器，包含了 Python3 的大多数基础语法， 主要运行在性能和内存有限的嵌入式芯片上。（注意 Micropython 不包含 Python3 的所有语法） K210 在硬件上集成了机器视觉和机器听觉能力， 是一款定位 AI 和 AIOT 市场的SoC，同时也是一颗方便的MCU。 Micropython 让我们在 K210 上编程更加简单快捷， 我们也将源代码开源在 github 上 比如我们需要寻找I2C总线上的设备，只需要使用如下代码即可实现： from machine import I2C i2c = I2C(I2C.I2C0, freq=100000, scl=28, sda=29) devices = i2c.scan() print(devices) 同样，我们需要实现一个呼吸灯，只需要如下代码： from machine import Timer,PWM import time tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PWM) ch = PWM(tim, freq=500000, duty=50, pin=board_info.LED_G) duty=0 dir = True while True: if dir: duty += 10 else: duty -= 10 if duty>100: duty = 100 dir = False elif duty 这篇文档的内容 所有关于 MaixPy 的内容， 包括： 如何选择并得到一款合适自己的模块或者开发板 如何开始上手使用 学习关于 Micropython 的基础知识 库和接口（API）文档查询 让我们开始打开 MaixPy 的神奇大门吧 首先我们选择一款适合自己的开发板， 目前有如下几款高性价比的开发板（核心板）： 使用了 Sipeed M1(荔枝丹) 模块的 Dan dock Sipeed Maix BiT Sipeed Go 要获得这些板子，可以访问Sipeed（矽速）官网Sipeed official website，或者官方淘宝店 更多硬件的资料点击这里查看 然后开始探索如何使用MaixPy吧 MaixPy 源码 MaixPy 源码是指 运行在 K210 上的 Micropython 的解析器， 使用 C语言 编写，如果只是想使用MaixPy，不需要了解源码； 如果想参与开发MaixPy的内置功能，可以下载进行开发，欢迎大家提交PR MaixPy 源码托管在 github 本项目主要由 ©Sipeed Co.,Ltd. 维护， 并接受来自开源社区的贡献， 具体贡献这见贡献者列表 MaixPy 文档源码 修改代码后，文档也会随之更新， 文档源码托管在 github 分支 文档自动构建状态 master dev 反馈 关于本文档或者功能或者源码方面的问题，也欢迎提交issue: 文档 反馈 源码/功能 反馈 "},"hardware/k210.html":{"url":"hardware/k210.html","title":"芯片K210","keywords":"","body":"K210 Kendryte K210 是集成机器视觉与机器听觉能力的系统级芯片 (SoC) 。使用台积电 (TSMC) 超低功耗的 28 纳米先进制程,具有双核 64 位处理器,拥有较好的功耗性能,稳定性与可靠性。 该方案力求零门槛开发,可在最短时效部署于用户的产品中,赋予产品人工智能。 Kendryte K210 定位于 AI 与 IoT 市场的 SoC ,同时是使用非常方便的 MCU 。 Kendryte 中文含义为勘智,而勘智取自勘物探智。这颗芯片主要应用领域为物联网领域,在物联网领域进行开发,因此为勘物;这颗芯片主要提供的是人工智能解决方案,在人工智能领域探索,因此为探智。 具备机器视觉能力 具备机器听觉能力 更好的低功耗视觉处理速度与准确率 具备卷积人工神经网络硬件加速器 KPU ,可高性能进行卷积人工神经网络运算 TSMC 28nm 先进制程,温度范围 -40°C 到 125°C ,稳定可靠 支持固件加密,难以使用普通方法破解 独特的可编程 IO 阵列,使产品设计更加灵活 低电压,与相同处理能力的系统相比具有更低功耗 3.3V/1.8V 双电压支持,无需电平转换,节约成本 AI 解决方案 机器视觉 Kendryte K210 具备机器视觉能力,是零门槛机器视觉嵌入式解决方案。它可以在低功耗情况下进行卷积神经网络计算。 该芯片可以实现以下机器视觉能力: 基于卷积神经网络的一般目标检测 基于卷积神经网络的图像分类任务 人脸检测和人脸识别 实时获取被检测目标的大小与坐标 实时获取被检测目标的种类 机器听觉 Kendryte K210 具备机器听觉能力。芯片上自带高性能麦克风阵列音频处理器,可以进行实时声源定向与波束形成。 该芯片可以实现以下机器听觉能力: 声源定向 声场成像 波束形成 语音唤醒 语音识别 视觉 / 听觉混合解决方案 Kendryte K210 可结合机器视觉和机器听觉能力,提供更强大的功能。一方面,在应用中既可以通过声源定位和声场成像辅助机器视觉对目标的跟踪,又可以通过一般目标检测获得目标的方位后辅助机器听觉对该方位进行波束形成。另一方面,可以通过摄像头传来的图像获得人的方向后,使得麦克风阵列通过波束形成指向该人。同时也可以根据麦克风阵列确定一个说话人的方向,转动摄像头指向该人。 资料下载 Kendryte 官网下载页面 其中必看的有 datasheet Kendryte Github "},"hardware/module.html":{"url":"hardware/module.html","title":"模组","keywords":"","body":"K210 模组 Sipeed M1 (荔枝丹) "},"hardware/m1.html":{"url":"hardware/m1.html","title":"Sipeed M1","keywords":"","body":"Sipeed M1/M1W (Lichee Dan) M1/M1W M1: K210全引脚引出， 芯片内置 8M SRAM， 模块内置 16M Flash M1W是带 WiFi（esp8285） 版本 资料下载 芯片 K210 Datasheet: Kendryte 官网 规格书: 在线查看, 百度云 封装: "},"hardware/board.html":{"url":"hardware/board.html","title":"开发板","keywords":"","body":"Board there's three kind of board as follow: Dan dock with Sipeed M1(Dan) module Sipeed Maix BiT Sipeed Go "},"hardware/dan_dock.html":{"url":"hardware/dan_dock.html","title":"Dan Dock","keywords":"","body":"Sipeed M1 (Lichee Dan) Dan dock with Sipeed M1(Dan) module 资料下载 原理图： 在线查看， 百度云 封装： "},"hardware/bit.html":{"url":"hardware/bit.html","title":"BiT","keywords":"","body":"Sipeed Maix BiT 资料下载 原理图： 在线查看， 百度云 封装： "},"hardware/go.html":{"url":"hardware/go.html","title":"Go","keywords":"","body":"Sipeed Maix Go 资料下载 原理图： 在线查看， 百度云 封装： "},"hardware/peripheral_modules.html":{"url":"hardware/peripheral_modules.html","title":"外设模块","keywords":"","body":"外设模块 麦克风阵列 双目摄像头 "},"get_started/prepare.html":{"url":"get_started/prepare.html","title":"准备","keywords":"","body":"准备工作 获得开发板 更新MAIXPY固件 "},"get_started/get_hardware.html":{"url":"get_started/get_hardware.html","title":"获得开发板","keywords":"","body":"获得开发板 从Sipeed官方淘宝店获得心仪的硬件： 淘宝 需要的硬件 一款开发板 可以从 这里 选一款 USB Type C 连接线 从淘宝官方购买可以询问是否附送 屏幕 从淘宝官方购买可以询问是否包含 摄像头 从淘宝官方购买可以询问是否包含 "},"get_started/upgrade_firmware.html":{"url":"get_started/upgrade_firmware.html","title":"更新MaixPy固件","keywords":"","body":"更新 MaixPy 固件 连接硬件 连接 Type C 线， 一端到开发板， 一端到电脑 安装驱动 主要是安装串口驱动，因为板子是通过 USB 转串口设备与电脑连接。 根据板子的 USB 转串口芯片型号装驱动。 比如 CH340： Linux 不需要装驱动，系统自带了，使用ls /dev/ttyUSB* 即可看到设备号 Windows 在网上搜索一下下载安装即可，然后可以在设备管理器中看到串口设备 获得升级工具 Ubuntu(Linux) 下载工具：kflash.py sudo apt update sudo apt install git python3 python3-pip sudo pip3 install pyserial git clone https://github.com/sipeed/kflash.py Windows K-Flash： 从 github 下载 或者从 kendryte 官方页面下载 获得固件 从 github 页面下载 下载固件到开发板 Linux 使用如下命令来进行烧录，可以使用python3 kflash.py --help来获取帮助 sudo python3 kflash.py -p /dev/ttyUSB0 -b 2000000 -B dan firmware.bin 其中 -p 是指定设备， 可以通过ls /dev/ttyUSB*来查看设备 -b是指定波特率， 如果下载失败，可以降低波特率再次尝试 -B是指定板子，如果没有支持的型号也不用担心，仍然可以下载，只是下载完后可能需要手动复位才能启动 如果不想每次都使用sudo命令， 执行sudo usermod -a -G dialout $(whoami) 将自己添加到dialout用户组即可，可能需要注销或者重启才能生效 Windows 双机运行下载的软件，运行后选择固件、串口等，点击下载即可 "},"get_started/power_on.html":{"url":"get_started/power_on.html","title":"点亮板子","keywords":"","body":"点亮设备，第一次接触MaixPy 连接硬件 连接 Type C 线， 一端电脑一端开发板 使用串口工具 Linux 使用minicom 或者 screen等工具即可 Screen sudo apt update sudo apt install screen sudo screen /dev/ttyUSB0 115200 然后点击回车键，即可看到 MaixPy 的交互界面了 >>> 输入 help()，可以查看帮助 要退出minicom， 按 Ctrl+A K，然后按 Y 确认退出即可 minicom sudo apt update sudo apt install minicom sudo minicom -s # 然后根据提示设置串口号以及波特率为 115200 等，不懂可以利用搜索工具搜索 sudo minicom 进入minicom后点击回车键，即可看到 MaixPy 的交互界面了 >>> 输入 help()，可以查看帮助 要退出minicom， 按 Ctrl+A X，按 Enter 确认退出即可 Windows 使用如 putty 等工具 然后选择串口模式， 然后设置串口和波特率，打开串口。 然后点击回车键，即可看到 MaixPy 的交互界面了 >>> 输入 help()，可以查看帮助 "},"get_started/led_blink.html":{"url":"get_started/led_blink.html","title":"点灯工程师(LED)","keywords":"","body":""},"get_started/how_to_read.html":{"url":"get_started/how_to_read.html","title":"如何正确阅读本文档","keywords":"","body":"如何正确使用（/阅读）本文 刚接触，可以根据左边侧边栏的目录从上到下一页一页仔细看，跟着做即可。 然后学会如何更新固件，如何写代码 最后关于模块的接口及参数，在使用时根据自己的需求进行查阅，左上角有搜索框，可以好好利用，同时也可以使用浏览器的页面搜索功能，即按键盘Ctrl+F，然后输入要搜索的内容后按确认键 如果有找不到的内容也请不要着急， 可以上 github 的 issue（文档 issue， 代码 issue） 页面找一找（/搜一搜）是不是有人提过了，没有的话可以新建 issue ， 或者联系技术支持。 "},"mpy_basic_syntax/":{"url":"mpy_basic_syntax/","title":"基础语法","keywords":"","body":"Micropython basic syntax "},"libs/":{"url":"libs/","title":"库（API）","keywords":"","body":"Libraries standard：基础库，比如 math， time 等 machine：与硬件相关的模块，比如 I2C，SPI 等 "},"libs/standard/":{"url":"libs/standard/","title":"标准库","keywords":"","body":"标准库 cmath gc math sys ubinascii ucollections uctypes uerrno uheapq ujson uos ure uselect ustruct utime uzlib "},"libs/standard/cmath.html":{"url":"libs/standard/cmath.html","title":"cmath","keywords":"","body":"cmath – 复数的数学函数 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档： cmath. cmath模块提供了一些处理复数的基本数学函数。 函数 cos cmath.cos(z) 返回z的余弦。 exp cmath.exp(z) 返回z的指数。 log cmath.log(z) 返回z的自然对数。分支切割沿负实轴。 log10 cmath.log10(z) 返回z的以10为底的对数。分支切割沿负实轴。 phase cmath.phase(z) 返回数字“z”的相位，范围（-pi，+ pi）。 polar cmath.polar(z) 作为元组返回z的极性形式。 rect cmath.rect(r, phi) 返回模数r和相位phi的复数。 sin cmath.sin(z) 返回z的正弦值。 sqrt cmath.sqrt(z) 返回z的平方根。 Constants cmath.e 自然对数的基础 cmath.pi 圆周长与直径的比值 "},"libs/standard/gc.html":{"url":"libs/standard/gc.html","title":"gc","keywords":"","body":"gc – 控制垃圾收集器 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：gc. 函数 gc.enable() 启用自动垃圾回收。 gc.disable() 禁用自动垃圾回收。仍然可以分配堆内存，仍然可以使用 gc.collect() 手动启动垃圾收集。 gc.collect() 运行垃圾回收。 gc.mem_alloc() 返回分配的堆RAM的字节数。 Difference to CPython 此功能是MicroPython扩展。 gc.mem_free() 返回可用堆RAM的字节数，如果堆剩余数量未知，则返回-1。 与CPython的区别 此功能是MicroPython扩展。 gc.threshold([amount]) 设置或查询其他GC分配阈值。通常，仅当不能满足新分配时，即在内存不足（OOM）条件下才触发集合。如果调用此函数，除了OOM之外，每次分配了大量字节后都会触发一个集合（总共，因为上一次分配了这么多的字节）。 amount通常被指定为小于完整堆大小，意图在堆耗尽之前触发集合，并希望早期集合可以防止过多的内存碎片。这是一种启发式度量，其效果因应用程序而异，以及量参数的最佳值。 不带参数调用函数将返回阈值的当前值。值-1表示禁用的分配阈值。 与CPython的区别 此函数是MicroPython扩展。 CPython有一个类似的函数 - set_threshold()，但是由于不同的GC实现，它的签名和语义是不同的。 "},"libs/standard/math.html":{"url":"libs/standard/math.html","title":"math","keywords":"","body":"math – 数学函数 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：math. math模块提供了一些处理浮点数的基本数学函数。 函数 math.acos(x) 返回x的反余弦值。 math.acosh(x) 返回x的反双曲余弦值。 math.asin(x) 返回x的反正弦。 math.asinh(x) 返回x的反双曲正弦值。 math.atan(x) 返回x的反正切。 math.atan2(y, x) 返回y /x的反正切的主值。 math.atanh(x) 返回x的反双曲正切。 math.ceil(x) 返回一个整数，“x”向正无穷大四舍五入。 math.copysign(x, y) 以y的符号返回x。 math.cos(x) 返回x的余弦。 math.cosh(x) 返回x的双曲余弦值 math.degrees(x) 返回弧度x转换为度数。 math.erf(x) 返回x的错误函数。 math.erfc(x) 返回x的互补误差函数。 math.exp(x) 返回x的指数。 math.expm1(x) 返回exp（x） - 1。 math.fabs(x) 返回x的绝对值。 math.floor(x) 返回一个整数，“x”向负无穷大舍入。 math.fmod(x, y) 返回x /y的余数。 math.frexp(x) 将浮点数分解为尾数和指数。返回的值是元组（m，e），使得x == m * 2 ** e完全正确。如果x == 0则函数返回（0.0,0），否则关系0.5 成立。 math.gamma(x) 返回x的伽玛函数。 math.isfinite(x) 如果x是有限的，则返回True。 math.isinf(x) 如果x是无限的，则返回True。 math.isnan(x) 如果x不是数字，则返回True math.ldexp(x, exp) 返回x *（2 ** exp）。 math.lgamma(x) 返回x的伽玛函数的自然对数。 math.log(x) 返回x的自然对数。 math.log10(x) 返回x的以10为底的对数。 math.log2(x) 返回x的base-2对数。 math.modf(x) 返回两个浮点数的元组，是“x”的分数和整数部分。两个返回值都与x具有相同的符号。 math.pow(x, y) 将x返回到'y`的幂。 math.radians(x) 返回度数x转换为弧度。 math.sin(x) 返回x的正弦值。 math.sinh(x) 返回x的双曲正弦值。 math.sqrt(x) 返回x的平方根。 math.tan(x) 返回x的正切值。 math.tanh(x) 返回x的双曲正切。 math.trunc(x) 返回一个整数，“x”向0舍入。 Constants math.e 自然对数的基础 math.pi 圆周长与直径的比值 "},"libs/standard/sys.html":{"url":"libs/standard/sys.html","title":"sys","keywords":"","body":""},"libs/standard/ubinascii.html":{"url":"libs/standard/ubinascii.html","title":"ubinascii","keywords":"","body":"ubinascii – 二进制/ ASCII转换 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：binascii. 该模块以ASCII格式（两个方向）实现二进制数据与其各种编码之间的转换。 函数 ubinascii.hexlify(data[, sep]) 将二进制数据转换为十六进制表示。返回字节字符串。 与CPython的区别 如果提供了附加参数sep，则它将用作十六进制值之间的分隔符。 ubinascii.unhexlify(data) 将十六进制数据转换为二进制表示。返回字节字符串。 （即hexlify的倒数） ubinascii.a2b_base64(data) 解码base64编码的数据，忽略输入中的无效字符。符合 RFC 2045 s.6.8. 返回一个bytes对象。 ubinascii.b2a_base64(data) 以base64格式编码二进制数据，如 RFC 3548所述。返回编码数据，后跟换行符，作为bytes对象。 "},"libs/standard/ucollections.html":{"url":"libs/standard/ucollections.html","title":"ucollections","keywords":"","body":"ucollections – 集合和容器类型 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档 collections. 此模块实现高级集合和容器类型以保存/累积各种对象。 类 ucollections.deque(iterable, maxlen[, flags]) Deques（双端队列）是一个类似列表的容器，支持O（1）追加并从双端队列的任一侧弹出。使用以下参数创建新的deques： iterable必须是空元组，并且新的deque被创建为空。 必须指定maxlen，并且双端队列将限制为此最大长度。一旦双端队列已满，添加的任何新项目将丢弃对方的项目。 添加项目时，可选标志可以为1以检查溢出。 除了支持bool和len之外，deque对象还有以下方法： deque.append(x) 将x添加到双端队列的右侧。如果启用了溢出检查并且没有剩余空间，则引发 IndexError。 deque.popleft() 从双端队列的左侧移除并返回一个项目。如果没有项目，则引发 IndexError。 ucollections.namedtuple(name, fields) 这是工厂函数，用于创建具有特定名称和字段集的新的namedtuple类型。 namedtuple是元组的子类，它不仅可以通过数字索引访问其字段，还可以使用符号字段名称访问属性访问语法。 Fields是指定字段名称的字符串序列。为了与CPython兼容，它也可以是一个以空格分隔的字段命名的字符串（但效率较低）。使用示例： from ucollections import namedtuple MyTuple = namedtuple(\"MyTuple\", (\"id\", \"name\")) t1 = MyTuple(1, \"foo\") t2 = MyTuple(2, \"bar\") print(t1.name) assert t2.name == t2[1] ucollections.OrderedDict(...) dict类型子类，它记住并保留添加的键的顺序。当迭代命令dict时，按照添加的顺序返回键/项： from ucollections import OrderedDict # To make benefit of ordered keys, OrderedDict should be initialized # from sequence of (key, value) pairs. d = OrderedDict([(\"z\", 1), (\"a\", 2)]) # More items can be added as usual d[\"w\"] = 5 d[\"b\"] = 3 for k, v in d.items(): print(k, v) Output: z 1 a 2 w 5 b 3 "},"libs/standard/uerrno.html":{"url":"libs/standard/uerrno.html","title":"uerrno","keywords":"","body":"uerrno — 系统错误代码 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：errno。 该模块描述了 OSError 错误的错误标识。特定的代码库存取决于 Micropython 的移植， 错误会在特定的会出现错误的函数进行说明。 常量 EEXIST, EAGAIN, 等 基于 ANSI C / POSIX 标准的错误代码。所有错误代码均以 “E” 开头。如上所述，代码库存取决于 MicroPython 的移植。错误通常可以作为exc.args [0]访问，其中exc是OSError的一个实例。用法示例： try: uos.mkdir(\"my_dir\") except OSError as exc: if exc.args[0] == uerrno.EEXIST: print(\"Directory already exists\") uerrno.errorcode 字典将数字错误代码映射到带有符号错误代码的字符串（参见上文）： >>> print(uerrno.errorcode[uerrno.EEXIST]) EEXIST "},"libs/standard/uheapq.html":{"url":"libs/standard/uheapq.html","title":"uheapq","keywords":"","body":"uheapq – 堆队列算法 该模块实现了对应 CPython 模块的子集，如下所述。 有关更多信息，请参阅原始CPython文档：heapq。 该模块实现堆队列算法。 堆队列只是一个以某种方式存储其元素的列表。 函数 heappush uheapq.heappush(heap, item) 将元素放入堆。 heappop uheapq.heappop(heap) 弹出堆中的第一个元素，然后将其返回。 如果heap为空，则引发IndexError。 heapify uheapq.heapify(x) 将列表x转换为堆。 这是一个 in-place（划分交换排序）操作。 "},"libs/standard/uos.html":{"url":"libs/standard/uos.html","title":"uos","keywords":"","body":"os "},"libs/standard/ure.html":{"url":"libs/standard/ure.html","title":"ure","keywords":"","body":""},"libs/standard/uselect.html":{"url":"libs/standard/uselect.html","title":"uselect","keywords":"","body":""},"libs/standard/ustruct.html":{"url":"libs/standard/ustruct.html","title":"ustruct","keywords":"","body":"ustruct – 打包和解包原始数据类型 该模块实现了相应的CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档： struct. 支持的大小/字节顺序前缀: @, , >, !. 支持的格式代码： b, B, h, H, i, I, l, L, q, Q, s, P, f, d （后者2取决于浮点支持）。 函数 calcsize ustruct.calcsize(fmt) 返回存储给定fmt所需的字节数。 pack ustruct.pack(fmt, v1, v2, ...) 根据格式字符串fmt打包值v1，v2，...。返回值是编码值的字节对象。 pack_into ustruct.pack_into(fmt, buffer, offset, v1, v2, ...) 根据格式字符串fmt将值v1，v2，...打包到从offset开始的缓冲区中。从缓冲区的末尾开始计数可能是负数。 unpack ustruct.unpack(fmt, data) 根据格式字符串fmt从data解包。返回值是解压缩值的元组。 unpack_from ustruct.unpack_from(fmt, data, offset=0) 根据格式字符串fmt从 offset 开始从data解包。 offset可能是负数，从缓冲区的末尾开始计数。返回值是解压缩值的元组。 "},"libs/standard/utime.html":{"url":"libs/standard/utime.html","title":"utime","keywords":"","body":"utime – 时间相关的功能 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档： time. utime模块提供获取当前时间和日期，测量时间间隔和延迟的功能。 时间纪元: Unix移植版本使用标准为1970-01-01 00:00:00 UTC的POSIX系统时代。但是，嵌入式移植版本使用的是2000-01-01 00:00:00 UTC的纪元。 维护实际日历日期/时间: 这需要实时时钟（RTC）。在具有底层OS（包括一些RTOS）的系统上，RTC可能是隐含的。设置和维护实际日历时间是OS / RTOS的责任，并且在MicroPython之外完成，它只使用OS API来查询日期/时间。在裸机移植上，系统时间依赖于machine.RTC（）对象。可以使用machine.RTC（）。datetime（tuple）函数设置当前日历时间，并通过以下方式维护： 通过备用电池（可能是特定电路板的附加可选组件）。 使用联网时间协议（需要由移植/用户设置）。 每次上电时由用户手动设置（许多电路板在硬复位时保持RTC时间，但有些可能需要在这种情况下再次设置）。 如果未使用系统/ MicroPython RTC维护实际日历时间，则低于此要求参考当前绝对时间的函数可能与预期不符。 函数 utime.localtime([secs]) 将自纪元（见上文）以秒为单位的时间转换为8元组，其中包含:(年，月，日，小时，分钟，秒，工作日，晚期）如果未提供秒数或无，则为当前时间来自RTC使用。 年份包括世纪（例如2014年）。 月是1-12 mday是1-31 小时是0-23 分钟是0-59 秒是0-59 周一至周日的工作日为0-6 yearday是1-366 utime.mktime() 这是本地时间的反函数。它的参数是一个完整的8元组，表示按当地时间表示的时间。它返回一个整数，它是自2000年1月1日以来的秒数。 utime.sleep(seconds) 睡眠给定的秒数。有些电路板可能会接受秒作为浮点数来休眠几秒钟。请注意，其他板可能不接受浮点参数，因为与它们的兼容性使用 sleep_ms() 和 sleep_us() 函数。 utime.sleep_ms(ms) 给定毫秒数的延迟应为正或0。 utime.sleep_us(us) 给定微秒数的延迟应为正或0。 utime.ticks_ms() 返回一个带有任意参考点的递增毫秒计数器，它在某个值之后回绕。 环绕值未明确公开，但我们将其称为TICKS_MAX以简化讨论。值的周期为TICKS_PERIOD = TICKS_MAX + 1. TICKS_PERIOD保证为2的幂，但在不同硬件的移植之间可能不同。相同的句点值用于所有ticks_ms（），ticks_us（），ticks_cpu（）函数（为简单起见）。因此，这些函数将返回范围[0 .. TICKS_MAX]中的值，包括总TICKS_PERIOD值。请注意，仅使用非负值。在大多数情况下，您应该将这些函数返回的值视为不透明。可用的唯一操作是ticks_diff（）和ticks_add（）函数，如下所述。 注意：直接对这些值执行标准数学运算（+， - ）或关系运算符（，> =）将导致无效结果。执行数学运算然后将其结果作为参数传递给ticks_diff（）或ticks_add（）也将导致后者函数的无效结果。 utime.ticks_us() 就像上面的'ticks_ms（）`一样，但是在几微秒内。 utime.ticks_cpu() 类似于ticks_ms（）和ticks_us（），但系统中的分辨率最高。这通常是CPU时钟，这就是函数以这种方式命名的原因。但它不必是CPU时钟，而是可以使用系统中可用的一些其他定时源（例如，高分辨率定时器）。在'utime`模块级别没有指定此函数的确切时间单位（分辨率），但特定硬件的文档可能提供更具体的信息。此功能用于非常精细的基准测试或非常紧凑的实时循环。避免在便携式代码中使用它。 utime.ticks_add(ticks, delta) 偏移值按给定数字计算，可以是正数也可以是负数。给定一个ticks值，该函数允许在tick值的模块算术定义之后或之后计算ticks值delta ticks（参见上面的ticks_ms（））。 ticks参数必须是调用ticks_ms（），ticks_us（）或ticks_cpu（）函数（或从之前调用ticks_add（））的直接结果。但是，delta可以是任意整数或数字表达式。 ticks_add（）对于计算事件/任务的截止日期非常有用。 （注意：你必须使用ticks_diff（）函数来处理截止日期。） 例子: # Find out what ticks value there was 100ms ago print(ticks_add(time.ticks_ms(), -100)) # Calculate deadline for operation and test for it deadline = ticks_add(time.ticks_ms(), 200) while ticks_diff(deadline, time.ticks_ms()) > 0: do_a_little_of_something() # Find out TICKS_MAX used by this port print(ticks_add(0, -1)) utime.ticks_diff(ticks1, ticks2) 测量从ticks_ms（），ticks_us（）或ticks_cpu（）函数返回的值之间的差异，作为可以回绕的有符号值。 参数顺序与减法运算符相同，ticks_diff（ticks1，ticks2）与ticks1 - ticks2具有相同的含义。但是，ticks_ms（）等函数返回的值可能会回绕，因此直接使用减法会产生不正确的结果。这就是为什么需要ticks_diff（），它实现模块化（或更具体地说，环）算术，即使对于环绕值也能产生正确的结果（只要它们之间不太远，见下文）。该函数返回范围为[-TICKS_PERIOD / 2 .. TICKS_PERIOD / 2-1]的有符号值（这是二进制补码有符号二进制整数的典型范围定义）。如果结果是否定的，则意味着ticks1在时间上早于ticks2。否则，这意味着ticks1发生在ticks2之后。如果ticks1和ticks2彼此分开不超过TICKS_PERIOD / 2-1滴答，则仅保留**。如果不成立，将返回不正确的结果。具体来说，如果两个刻度值相隔TICKS_PERIOD / 2-1刻度，则该值将由该函数返回。但是，如果实时滴答的TICKS_PERIOD / 2已在它们之间传递，则该函数将返回-TICKS_PERIOD / 2，即结果值将回绕到可能值的负范围。 上述限制的非正式理由：假设您被锁在一个房间内，除了标准的12档时钟外无法监控时间的流逝。然后，如果你现在看表盘，不再看13个小时（例如，如果你长时间睡觉），那么一旦你再看一遍，你可能觉得只有1个小时过去了。为了避免这个错误，请定期查看时钟。您的应用程序也应该这样做。 “太长时间睡眠”这个比喻也直接映射到应用程序行为：不要让你的应用程序运行任何单个任务太长时间。分步运行任务，并在两者之间进行计时。 ticks_diff() 旨在适应各种使用模式，其中包括： 超时轮询。在这种情况下，事件的顺序是已知的，你只会处理ticks_diff（）的正面结果： # Wait for GPIO pin to be asserted, but at most 500us start = time.ticks_us() while pin.value() == 0: if time.ticks_diff(time.ticks_us(), start) > 500: raise TimeoutError 调度事件。 在这种情况下，如果事件过期，则ticks_diff（）结果可能为负： # This code snippet is not optimized now = time.ticks_ms() scheduled_time = task.scheduled_time() if ticks_diff(scheduled_time, now) > 0: print(\"Too early, let's nap\") sleep_ms(ticks_diff(scheduled_time, now)) task.run() elif ticks_diff(scheduled_time, now) == 0: print(\"Right at time!\") task.run() elif ticks_diff(scheduled_time, now) 注意：不要将time（）值传递给ticks_diff（），你应该对它们使用常规的数学运算。但请注意，time（）可能（也会）溢出。这被称为https://en.wikipedia.org/wiki/Year_2038_problem . utime.time() 返回自纪元以来的整数秒数，假设如上所述设置和维护基础RTC。如果未设置 RTC，则此函数返回自特定硬件移植参考时间点以来的秒数（对于没有电池供电的 RTC 的嵌入式电路板，通常自上电或复位后）。如果要开发便携式 MicroPython 应用程序，则不应依赖此函数来提供高于第二的精度。如果你需要更高的精度，使用ticks_ms（）和ticks_us（）函数，如果你需要日历时间，localtime（）没有参数是一个更好的选择。 与CPython的区别 在 CPython 中，此函数返回自 Unix 纪元（1970-01-01 00:00 UTC）以来的秒数，作为浮点数，通常具有微秒精度。 使用 MicroPython，只有 Unix 移植版本使用相同的纪元，如果浮点精度允许，则返回亚秒精度。 嵌入式硬件通常没有浮点精度来表示长时间范围和亚秒精度，因此它们使用具有第二精度的整数值。 某些嵌入式硬件也缺少电池供电的 RTC，因此返回自上次上电或其他相对硬件特定点（例如复位）以来的秒数。 "},"libs/standard/uzlib.html":{"url":"libs/standard/uzlib.html","title":"uzlib","keywords":"","body":"uzlib — zlib 解压缩 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：zlib。 该模块允许解压使用 DEFLATE 算法压缩的二进制数据（通常用于zlib库和gzip存档器）。 压缩尚未实现。 函数 decompress 解压 uzlib.decompress(data, wbits=0, bufsize=0) 参数 wbits： 压缩期间使用的 DEFLATE 字典窗口大小（8-15，字典大小是该值的2的幂）。 另外，如果值为正，则假定数据为 zlib 流（使用 zlib 头）。 否则，如果它是负数，则假定它是原始 DEFLATE 流。 bufsize： 参数用于与CPython兼容， 可忽略。 返回值 将解压缩的数据作为bytes类型返回。 DecompIO 创建一个流包装器，允许对另一个流中的压缩数据进行透明解压缩。 这允许处理具有大于可用堆大小的数据的压缩流。 除了decompress（）中描述的值之外，wbits可以取值 24..31（16+8..15），这意味着输入流具有gzip头。 class uzlib.DecompIO(stream, wbits=0) 与 CPython 的不同 这个类是MicroPython扩展。它包含在临时基础上，可能会在以后的版本中进行大量更改或删除。 "},"libs/machine/":{"url":"libs/machine/","title":"machine","keywords":"","body":"machine machine 库主要包含了与硬件相关的各种接口，如下： I2C SPI Timer PWM UART "},"libs/machine/i2c.html":{"url":"libs/machine/i2c.html","title":"I2C","keywords":"","body":"machine.I2C I2C 总线协议，简单地使用两条线（SCL，SDA）可以控制多个从机（主机模式）。 支持主机模式和从机模式 7 位/10 位寻址模式 标准模式 快速模式 超快速模式 高速模式 3.4Mb/s 构造函数 class machine.I2C(id, mode=Timer.MODE_MASTER, scl, sda, freq=400000, timeout=1000, addr=0, addr_size=7, on_recieve=None, on_transmit=None, on_event=None) 通过指定的参数新建一个 I2C 对象 参数 id： I2C ID, [0~2] (I2C.I2C0~I2C.I2C2) mode： 模式， 主机(I2C.MODE_MASTER)和从机（I2C.MODE_SLAVE)模式 scl： SCL 引脚，直接传引脚编号即可，取值范围： [0,47] sda： SDA 引脚，直接传引脚编号即可，取值范围： [0,47] freq： I2C通信频率， 支持标准100Kb/s, 快速400Kb/s， 以及更高速率（硬件支持超快速模式1000Kb/s，以及高速模式3.4Mb/s） timeout： 超时时间，目前这个参数保留，设置无效 addr： 从机地址，如果是主机模式不用设置， 从机模式则代表从机（本机）地址 addr_size： 地址长度， 支持 7 位寻址和 10 位寻址， 取值7或者10 on_recieve： 从机模式的接收回调函数 on_transmit： 从机模式的发送回调函数 on_event： 从机模式的事件函数（开始事件和结束事件） 方法 init 类似构造函数 I2C.init(id, mode=Timer.MODE_MASTER, scl, sda, freq=400000, timeout=1000, addr=0, addr_size=7, on_recieve=None, on_transmit=None, on_event=None) 参数 与构造函数相同 返回值 无 scan 扫描I2C总线上的从机 I2C.scan() 参数 无 返回值 list 对象， 包含了所有扫描到的从机地址 readfrom 从总线读取数据 I2C.readfrom(addr, len, stop=True) 参数 addr: 从机地址 len： 数据长度 stop： 是否产生停止信号，保留，目前只能使用默认值Ture 返回值 读取到的数据，bytes 类型 readfrom_into 读取数据并放到制定变量中 I2C.readfrom_into(addr, buf, stop=True) 参数 addr: 从机地址 buf： bytearray类型， 定义了长度，读取到的数据存放在此 stop： 是否产生停止信号，保留，目前只能使用默认值Ture 返回值 无 writeto 发送数据到从机 I2C.writeto(addr, buf, stop=True) 参数 addr: 从机地址 buf： 需要发送的数据 stop： 是否产生停止信号，保留，目前只能使用默认值Ture 返回值 成功发送的字节数 readfrom_mem 读取从机寄存器 I2C.readfrom_mem(addr, memaddr, nbytes, mem_size=8) 参数 addr: 从机地址 memaddr： 从机寄存器地址 nbytes： 需要读取的长度 mem_size： 寄存器宽度， 默认为8位 返回值 返回bytes类型的读取到的数据 readfrom_mem_into 读取从机寄存器值到指定变量中 I2C.readfrom_mem_into(addr, memaddr, buf, mem_size=8) 参数 addr: 从机地址 memaddr： 从机寄存器地址 buf： bytearray类型， 定义了长度，读取到的数据存放在此 mem_size： 寄存器宽度， 默认为8位 返回值 无 writeto_mem 写数据到从机寄存器 I2C.writeto_mem(addr, memaddr, buf, mem_size=8) 参数 addr: 从机地址 memaddr： 从机寄存器地址 buf： 需要写的数据 mem_size： 寄存器宽度， 默认为8位 返回值 无 deinit/_del_ 注销I2C硬件，释放占用的资源，关闭I2C时钟 I2C.deinit() 参数 无 返回值 无 例子 i2c.deinit() 或者 del i2c 常量 I2C0: I2C 0 I2C1: I2C 1 I2C2: I2C 2 MODE_MASTER: 作为主机模式 MODE_SLAVE: 作为从机模式 I2C_EV_START: 事件类型，开始信号 I2C_EV_RESTART: 事件类型，重新开始信号 I2C_EV_STOP: 事件类型，结束信号 例程 例程 1： 扫描从机设备 from machine import I2C i2c = I2C(I2C.I2C0, freq=100000, scl=28, sda=29) devices = i2c.scan() print(devices) 例程 2： 读写 import time from machine import I2C i2c = I2C(I2C.I2C0, freq=100000, scl=28, sda=29) i2c.writeto(0x24,b'123') i2c.readfrom(0x24,5) 例程 3： 从机模式 from machine import I2C count = 0 def on_receive(data): print(\"on_receive:\",data) def on_transmit(): count = count+1 print(\"on_transmit, send:\",count) return count def on_event(event): print(\"on_event:\",event) i2c = I2C(I2C.I2C0, mode=I2C.MODE_SLAVE, scl=28, sda=29, addr=0x24, addr_size=7, on_receive=on_receive, on_transmit=on_transmit, on_event=on_event) 例程 4： OLED(ssd1306 128x64) import time from machine import I2C SSD1306_CMD = 0 SSD1306_DATA = 1 SSD1306_ADDR = 0x3c def oled_init(i2c): i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xAE, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x20, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x10, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xb0, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xc8, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x00, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x10, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x40, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x81, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xff, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xa1, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xa6, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xa8, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x3F, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xa4, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xd3, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x00, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xd5, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xf0, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xd9, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x22, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xda, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x12, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xdb, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x20, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x8d, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x14, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xaf, mem_size=8) def oled_on(i2c): i2c.writeto_mem(SSD1306_ADDR, 0x00, 0X8D, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0X14, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0XAF, mem_size=8) def oled_off(i2c): i2c.writeto_mem(SSD1306_ADDR, 0x00, 0X8D, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0X10, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0XAE, mem_size=8) def oled_fill(i2c, data): for i in range(0,8): i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xb0+i, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x10, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x01, mem_size=8) for j in range(0,128): i2c.writeto_mem(SSD1306_ADDR, 0x40, data, mem_size=8) i2c = I2C(I2C.I2C0, mode=I2C.MODE_MASTER, freq=400000, scl=28, sda=29, addr_size=7) time.sleep(1) oled_init(i2c) oled_fill(i2c, 0xff) "},"libs/machine/pwm.html":{"url":"libs/machine/pwm.html","title":"PWM","keywords":"","body":"machine.PWM PWM： 脉宽调制模块， 硬件支持的PWM， 可以指定任意引脚（0到47引脚） 每个 PWM 依赖于一个定时器， 即当定时器与 PWM 功能绑定后， 不能作为普通定时器使用了。 因为有 3 个定时器， 每个定时器有 4 个通道， 即最大可以同时产生 12 路 PWM 波形 构造函数 class machine.PWM(tim, freq, duty, pin, enable=True) 通过指定的参数新建一个 PWM 对象 参数 tim: 每个PWM依赖一个定时器来产生波形， 所以这里需要传一个定时器对象，这个定时器对象必须初始化时必须指定定时器 ID 和通道号 freq： PWM 波形频率 duty： PWM 占空比， 指高电平占整个周期的百分比，取值：[0,100] enable： 是否立即开始产生波形，默认位True，及对象生成后立即开始在指定的引脚上产生 PWM 波形 方法 init 类似构造函数 PWM.init(tim, freq, duty, pin, enable=True) 参数 与构造函数相同 返回值 无 freq 获取或者设置 PWM 频率 PWM.freq(freq) 参数 freq： PWM 频率， 可选参数， 如果不传参数则步设置只返回当前频率值 返回值 当前设置的实际的 PWM 频率 duty 获取或者设置 PWM 占空比 PWM.duty(duty) 参数 duty： PWM 占空比 可选， 如果不传参数则步设置只返回当前占空比值 返回值 当前设置的 PWM 占空比值 enable 使能 PWM 输出， 使指定的引脚上立即产生波形 PWM.enable() 参数 无 返回值 无 disable 失能 PWM 输出， 指定的引脚不再产生波形 PWM.disable() 参数 无 返回值 无 deinit/_del_ 注销 PWM 硬件，释放占用的资源，关闭 PWM 时钟 PWM.deinit() 参数 无 返回值 无 例子 pwm.deinit() 或者 del pwm 常量 无 例程 例程 1 （呼吸灯） from machine import Timer,PWM import time tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PWM) ch = PWM(tim, freq=500000, duty=50, pin=board_info.LED_G) duty=0 dir = True while True: if dir: duty += 10 else: duty -= 10 if duty>100: duty = 100 dir = False elif duty 例程 2 import time import machine tim = machine.Timer(machine.Timer.TIMER0, machine.Timer.CHANNEL0, mode=machine.Timer.MODE_PWM) ch0 = machine.PWM(tim, freq=3000000, duty=20, pin=board_info.LED_G, enable=False) ch0.enable() time.sleep(3) ch0.freq(2000000) print(\"freq:\",ch0.freq()) ch0.duty(60) time.sleep(3) ch0.disable() "},"libs/machine/spi.html":{"url":"libs/machine/spi.html","title":"SPI","keywords":"","body":"machine.SPI SPI（Serial Peripheral Interface） 是一个同步串行协议，由主机和从机组成。 标准4线模式由 SCK（SCLK）， CS（片选）， MOSI， MISO 4条线连接主从机 在 K210 上， SPI 有一下特征： 共有 4 个 SPI 设备， 其中 SPI0 、SPI1、 SPI3 只能工作在主机模式下， SPI2 只能工作在从机模式时下， 在 MaixPy 上， SPI3已经用来连接了 SPI Flash， 暂时保留， 以后如果有必要再考虑开放接口与 SPI Flash 分时复用 支持 1/2/4/8 线全双工模式， 在 MaixPy 中， 目前只支持标准（摩托罗拉）4线全双工模式（即 SCK， MOSI， MISO， CS 四个引脚） 最高传输速率45M 支持DMA 4个可配置任意引脚的硬件片选 构造函数 class machine.SPI(id, mode=SPI.MODE_MASTER, baudrate=500000, polarity=0, phase=0, bits=8, firstbit=SPI.MSB, sck, mosi, miso, cs0, cs1, cs2, cs3) 通过指定的参数新建一个 SPI 对象 参数 id： SPI ID， 取值范围[0,3]， 目前只支持 0 和 1， 并且只能是主机模式， 2 只能作为从机，目前未实现， 3 保留 mode： SPI 模式， MODE_MASTER 或者MODE_MASTER_2或者MODE_MASTER_4或者MODE_MASTER_8或者MODE_SLAVE， 目前只支持MODE_MASTER baudrate： SPI 波特率（频率） polarity： 极性， 取值为 0 或 1， 表示 SPI 在空闲时的极性， 0 代表低电平， 1 代表高电平 phase： 相， 取值位 0 或 1， 表示在时钟的第一个还是第二个跳变沿采集数据， 0 表示第一个， 1 表示第二个 bits： 数据宽度， 默认值为8， 取值范围[4,32] firstbit： 指定传输采用 MSB 还是 LSB 顺序传输， 默认 SPI.MSB sck: SCK（时钟）引脚， 可直接传引脚数值，取值范围：[0,47] mosi: MOSI（主机输出） 引脚， 可直接传引脚数值，取值范围：[0,47] miso: MISO（主机输入） 引脚， 可直接传引脚数值，取值范围：[0,47] cs0: CS0（片选） 引脚， 可直接传引脚数值，取值范围：[0,47] cs1: CS1（片选） 引脚， 可直接传引脚数值，取值范围：[0,47] cs2: CS2（片选） 引脚， 可直接传引脚数值，取值范围：[0,47] cs3: CS3（片选） 引脚， 可直接传引脚数值，取值范围：[0,47] d0~d7： 数据引脚， 在非标准4线模式中使用，目前保留 方法 init 类似构造函数 SPI.init(id, mode=SPI.MODE_MASTER, baudrate=500000, polarity=0, phase=0, bits=8, firstbit=SPI.MSB, sck, mosi, miso, cs0) 参数 与构造函数相同 返回值 无 read 读取数据 SPI.read(nbytes, write=0x00, cs=SPI.CS0) 参数 nbytes： 需要读取的长度 cs： 选择片选引脚， 在初始化时已经为cs0~cs3设置了引脚，这里只需要选择SPI.CS0~SPI.CS3即可，默认为SPI.CS0 write： 因为是全双工，设置在读取时MOSI引脚的值，默认为0x00，即始终为低电平 返回值 bytes类型的数据 readinto 读取数据，并放到指定变量中 SPI.readinto(buf, write=0x00, cs=SPI.CS0) 参数 buf： bytearray 类型， 定义了长度，读取完成后数据保存在此 cs： 选择片选引脚， 在初始化时已经为cs0~cs3设置了引脚，这里只需要选择SPI.CS0~SPI.CS3即可，默认为SPI.CS0 write： 因为是全双工，设置在读取时MOSI引脚的值，默认为0x00，即始终为低电平 返回值 无 write 发送数据 SPI.write(buf, cs=SPI.CS0) 参数 buf： bytearray 类型， 定义了数据及长度 cs： 选择片选引脚， 在初始化时已经为cs0~cs3设置了引脚，这里只需要选择SPI.CS0~SPI.CS3即可，默认为SPI.CS0 返回值 无 write_readinto 发送数据，同时读取数据到变量，即全双工 SPI.write(write_buf, read_buf, cs=SPI.CS0) 参数 write_buf： bytearray 类型， 定义了需要发送的数据及长度 read_buf： bytearray 类型， 定义了接收数据存放的位置 cs： 选择片选引脚， 在初始化时已经为cs0~cs3设置了引脚，这里只需要选择SPI.CS0~SPI.CS3即可，默认为SPI.CS0 返回值 无 deinit/_del_ 注销 SPI，释放硬件，关闭 SPI 时钟 SPI.deinit() 参数 无 返回值 无 例子 spi.deinit() 或者 del spi 常量 SPI0: SPI 0 SPI1: SPI 1 SPI2: SPI 2 MODE_MASTER: 作为主机模式 MODE_MASTER_2: 作为主机模式 MODE_MASTER_4: 作为主机模式 MODE_MASTER_8: 作为主机模式 MODE_SLAVE: 作为从机模式 MSB： MSB， 即先发送高位或高字节 LSB： LSB， 即先发送低位或者低字节 CS0： 片选0 CS1： 片选1 CS2： 片选2 CS3： 片选3 例程 例程 1： 基本读写 from machine import SPI spi1 = SPI(SPI.SPI1, mode=SPI.MODE_MASTER, baudrate=10000000, polarity=0, phase=0, bits=8, firstbit=SPI.MSB, sck=28, mosi=29, miso=30, cs0=27) w = b'1234' r = bytearray(4) spi1.write(w) spi1.write(w, cs=SPI.CS0) spi1.write_readinto(w, r) spi1.read(5, write=0x00) spi1.readinto(r, write=0x00) "},"libs/machine/timer.html":{"url":"libs/machine/timer.html","title":"Timer","keywords":"","body":"machine.Timer 硬件定时器，可以用来定时触发任务或者处理任务，设定时间到了后可以触发中断（调用回调函数），精度比软件定时器高。 需要注意的是，定时器在不同的硬件中可能会有不同的表现。MicroPython 的 Timer 类定义了在给定时间段内（或在一段延迟后执行一次回调）执行回调的基本操作，并允许特定的硬件上定义更多的非标准行为（因此不能移植到其他板）。 共有 3 个定时器， 每个定时器有 4 个通道可以使用 构造函数 class machine.Timer(id, channel, mode=Timer.MODE_ONE_SHOT, period=1000, unit=Timer.UNIT_MS, callback=None, arg=None, start=True, priority=1, div=0) 通过指定的参数新建一个 Timer 对象 参数 id: Timer ID, [0~2] (Timer.TIMER0~TIMER2) channel: Timer 通道, [Timer.CHANNEL0~Timer.CHANNEL3] mode: Timer 模式, MODE_ONE_SHOT 或者 MODE_PERIODIC 或者 MODE_PWM period: Timer 周期, 在启动定时器后 period 时间， 回调函数将会被调用，(0,~) unit: 设置周期的单位，默认位毫秒（ms），Timer.UNIT_S 或者 Timer.UNIT_MS 或者 Timer.UNIT_US 或者Timer.UNIT_NS callback: 定时器回调函数， 定义了两个参数， 一个是定时器对象Timer， 第二个是在定义对象是希望传的参数arg，更多请看arg参数解释 注意：回调函数是在中断中调用的，所以在回调函数中请不要占用太长时间以及做动态分配开关中断等动作 arg: 希望传给回调函数的参数，作为回调函数的第二个参数 start: 是否在对象构建成功后立即开始定时器， True：立即开始， False:不立即开启，需要调用start()函数来启动定时器 priority: 硬件定时器中断优先级， 与特定的CPU相关， 在K210中，取值范围是[1,7]， 值越小优先级越高 div: 硬件定时器分频器，取值范围[0,255]， 默认为0， clk_timer（定时器时钟频率） = clk_pll0（锁相环0频率）/2^(div+1) clk_timer*period(unit:s) 应该 =1 方法 init 类似构造函数 Timer.init(id, channel, mode=Timer.MODE_ONE_SHOT, period=1000, unit=Timer.UNIT_MS, callback=None, arg=None, start=True, priority=1, div=0) 参数 类似构造函数 返回值 无 callback 获取或者设置回调函数 Timer.callback(callback) 参数 callback： 设置的回调函数，可选参数， 如果不传参数，则只返回先有的回调函数 返回值 当前的回调函数 例子 def on_timer(timer,param): print(\"time up:\",timer) print(\"param:\",param) tim.callback(on_timer) print(on_timer, tim.callback()) period 获取或者设置定时周期 Timer.period(period) 参数 period： 可选参数，配置周期， 如果不传参数， 则只返回当前周期值 返回值 当前周期值 例子 tim.period(2000) print( tim.period() ) start 启动定时器 Timer.start() 参数 无 返回值 无 例子 tim.start() stop 停止定时器 Timer.stop() 参数 无 返回值 无 restart 重新开启定时器 Timer.restart() 参数 无 返回值 无 deinit/_del_ 注销定时器，并且注销硬件的占用，关闭硬件的时钟 Timer.deinit() 参数 无 返回值 无 例子 tim.deinit() 或者 del tim 常量 TIMER0: Timer0 id TIMER1: Timer1 id TIMER2: Timer2 id CHANNEL0: Timer 通道 0 CHANNEL1: Timer 通道 1 CHANNEL2: Timer 通道 2 CHANNEL3: Timer 通道 3 MODE_ONE_SHOT: Timer 只运行一次（回调一次） MODE_PERIODIC: Timer 始终运行（连续回调） MODE_PWM: 定时器不用来回调函数，用以产生PWM UNIT_S: 单位秒 (s) UNIT_MS: 单位毫秒 (ms) UNIT_US: 单位微秒 (us) UNIT_NS: 单位纳秒 (ns) 例程 例程 1 定时3秒后打印信息 from machine import Timer def on_timer(timer,param): print(\"time up:\",timer) print(\"param:\",param) tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_ONE_SHOT, period=3000, callback=on_timer, param=on_timer) print(\"period:\",tim.period()) tim.start() 例程 2 每隔 1 秒打印消息， 停止 5 秒后再重启， 5 秒后关闭并注销定时器 import time from machine import Timer def on_timer(timer,param): print(\"time up:\",timer) print(\"param:\",param) tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PERIODIC, period=1, unit=Timer.UNIT_S, callback=on_timer, param=on_timer, start=False, priority=1, div=0) print(\"period:\",tim.period()) tim.start() time.sleep(5) tim.stop() time.sleep(5) tim.restart() time.sleep(5) tim.stop() del tim "},"libs/machine/uart.html":{"url":"libs/machine/uart.html","title":"UART","keywords":"","body":"machine.UART "},"contribute/":{"url":"contribute/","title":"贡献","keywords":"","body":"参与贡献 由于是开源项目，欢迎大家参与进来共同改进MaixPy， 由于人数较多，所以我们需要共同的约定（包括格式、风格等） 主要有以下几个方面可以参与进来： 文档修改 MaixPy 固件 Bug 修复、功能优化、功能新增等 "},"contribute/doc_convention.html":{"url":"contribute/doc_convention.html","title":"文档风格","keywords":"","body":"文档规范 文档使用 gitbook 进行构建， 并使用简单高效的 Markdown 编写内容 文档源码托管在 github Markdown 语法 Markdown 的基础语法如果没接触过， 请花半个小时进行学习， 推荐github的教程： github Markdown 教程 在本文中， 以下几点我们需要注意： 标题类的语法标记必须使用空格隔开，大标题与正文之间需要一个空行，比如： ## 这是二级标题 * 这是列表项1 * 这是列表项2 而如下所示的则不是正确的，可能会导致解析器出现解析错误格式错乱等 ##这是二级标题 *这是列表项1 *这是列表项2 所有页面只有一个一级标题 由于需要自动生成目录，主要是为了保证自动生成的目录正确。 每个页面这样写 页面标题/一级标题 ======= (这里等号至少需要三个) ( 至少需要一个以上的空行，建议2行 ) ## 二级标题1 ( 这里不能使用一级标题，及不能用一个#号。 也不需要写序号，会自动生成序号) ( 空一行 ) 正文 ( 至少空一行) ### 三级标题 ( 类似二级标题, 也不需要写需要，会自动生成) 正文 ## 二级标题2 正文 链接 由于页面众多，而且需要链接图片等资源，在写链接时，均使用相对路径， 比如目录结构如下 assets/ (放公用的资源文件) | ----pic000.png en/ | ----- get_started/ | ---- assets/ (放get_started目录下md文件公用的资源文件) | ------ pic.png | ---- get_hardware.md | ---- how_to_read.md zh/ 如果在get_hardware.md中贴图片，将图片放进assets文件夹后，使用如下代码引用图片 ![pic](assets/pic.png) ![pic](../../assets/pic000.png) 中英文混写 在写中文文档时，在中文中夹杂英文尽量用空格隔开，标点符号尽量使用全角符号， 主要是为了显眼，让文档更优雅。 比如如下对比： 在 Micropython 中， 我们常常使用`deinit`来表示析构函数，而不是像 STM32 一样来表示设置默认值 在 Micropython 中， 我们常常使用deinit来表示析构函数，而不是像 STM32 一样来表示设置默认值 在Micropython中， 我们常常使用deinit来表示析构函数，而不是像STM32一样来表示设置默认值 在Micropython中， 我们常常使用deinit来表示析构函数，而不是像STM32一样来表示设置默认值 目录和文件名 生成的文档目录在对应语言的文件夹SUMMARY.md中编辑 源文档的文件夹尽量一个功能模块对应一个文件夹，资源文件（图片）放置到对应 md 文档的当前路径的 assets文件夹目录下，这样在增删修改时更方便 assets/ (放公用的资源文件) en/ | ----- get_started/ | ---- assets/ (放get_started目录下md文件公用的资源文件) | ---- get_hardware.md | ---- how_to_read.md zh/ 文件名除了README.md特殊，其它文件名使用 小写+下划线 的命名方式，比如 get_hardware.md 中英文（多语言）的页面文件目录结构和文件名相同 由于最后生成的页面中有多语言切换选项，点击切换后会直接访问对应语言的相同路径，所以中英文的目录结构和文件名必须相同。 比如英文正在访问en/get_started/how_to_read.md， 点击语言切换的按钮后，会自动访问zh/get_started/how_to_read.md， 如果这个文件不存在就会报404错误！ 模块文档内容 需要在文件头部包含模块的介绍 需要分点说明构造函数、函数、常量等 说明不能偷懒只简单将函数名称翻译一遍，需要详细说明函数的功能、参数的取值范围以及注意点 "},"contribute/code_convention.html":{"url":"contribute/code_convention.html","title":"代码风格","keywords":"","body":"代码规范 "},"others/open_projects.html":{"url":"others/open_projects.html","title":"开源项目","keywords":"","body":"与 MaixPy 相关的开源项目 如果你有什么跟 MaixPy 相关的开源项目， 欢迎通过邮件(support@sipeed.com)或者 issues 告诉我们，或者直接修改文档提交 PR 非常期待大家的好玩有趣或者实用的作品哦～～～ "}}